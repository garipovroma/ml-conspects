 \section{Рекомендательные системы}
 
 \subsection{Задача}
 Задача рекомендательной системы — найти для пользователя такие элементы заданного множества, которые с высокой вероятностью понравятся пользователю.
 
 Введем некоторые обозначения:
 \begin{itemize}
     \item Пользователи — множество U (users).
     \item Товары — множество I (items) - товары/фильмы/музыка/техника.
     \item Оценки - пусть парам <пользователь, товар> соответствует некоторая оценка $r$, выражающая заинтересованность пользователя в этом товаре $r: U \times I \rightarrow R$
 \end{itemize}
 
 Требуется по известным оценкам $r$ для каждого пользователя получить набор из $k$
 товаров, наиболее подходящих пользователю (т.е с максимальной оценкой $r$). Кроме того, часто влияет и порядок выданных товаров. 
 
 \subsection{Модели и признаки}
 
 Рассмотрим \textbf{baselines} - простые решения, позволяющие сделать начальную модель, с значениями метрик которой потом будем сравнивать будущие модели.
 
 Самым очевидным подходом будет найти среднее всех известных оценок $\mu$ и выдавать $\mu$ как ответ, если рейтинг неизвестен.
 
 Этот подход никак не учитывает свойства товара и пользователя. Например какой-то пользователь может ставить оценки в среднем меньшие, чем другой.
 
 Давайте найдем для каждого пользователя и товара средние значения отдельно и найдем, насколько они отличаются от $\mu$:
 
 $$b_u = \mu_u - \mu$$
 $$b_i = \mu_i - \mu$$
 $$r_{ui} = b_u + b_i + \mu$$ 
 
 В данный момент мы не учитываем, насколько вкусы пользователей похожи между собой. Поэтому можем немного модифицировать подсчет среднего:
 
 Будем считать среднее для всех товаров для выбранного пользователя, при этом
влияние других пользователей будет зависеть от их схожести с выбранным
пользователем:

$$\mu_{u_0} = \frac{\sum_U sim(u, u_0) \sum_I r_{ui}}{|Y|}$$

\subsection{Похожесть пользователей и товаров}
Обозначим за $I_{uv}$ - множество товаров, оценки для которых известны у пользователей $u$ и $v$ одновременно

Теперь можем посчитать сходство между пользователями c помощью корреляции Пирсона (либо другой метрики - например, посчитать какую-нибудь метрику, обратную расстоянию).

$$sim(u, v) = \frac{\sum_{I_{uv}} (r_{ui} - \mu_u)(r_{vi} - \mu_v)}{\sqrt{\sum_{I_{uv}} (r_{ui} - \mu_u)^2 \sum_{I_{uv}} (r_{vi} - \mu_v)^2}}$$

То же самое можно сделать и с товарами.

\subsection{Коллаборативная фильтрация}
Существуют подходы на основе сходств пользователей и на основе сходств товаров:
\subsubsection{User-based collaborative filtering}
Для текущего пользователя найдем множество пользователей, наиболее похожих на него:
$$U(u_0) = \{u \in U | sim(u_0, u) > \alpha \}$$
Теперь найдем средние значения оценок для всех товаров у этих пользователей.
\\
\\
\\
Проблема данного подхода в том, что он позволяет строить рекомендации только в том случае, если для данного пользователя существуют похожие на него. Если же
пользователь новый или нетипичный, то подобрать что-либо не получится.
\subsubsection{Item-based collaborative filtering}
Для текущего пользователя найдем множество товаров, наиболее похожих на заинтересовавшие пользователя.

В таком подходе решается проблема нетипичного пользователя, так как необязательно иметь пользователей со схожими интересами, и подход позволяет найти товары, похожие на интересные ему. 

Но в таком подходе есть и проблемы: есть вероятность, что вместо действительно интересных товаров будем рекомендовать популярные.

\subsection{Контентные модели}

Опишем товары векторами, называемыми \textbf{эмбэдингами}. Теперь мы можем посчитать расстояния в пространстве эмбэдингов. 
Это позволит нам обучить модели, которые будут предсказывать целевую переменную на основе характеристик товара, а не только на основе рейтингов, поставленных другими пользователями